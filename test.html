<input type="file" onchange="doRead(this);" /><input type="button" onclick="doRead(this.previousSibling);"/>
<pre id="p" style="white-space: pre-wrap"></pre>
<script>

var p = document.getElementById('p');
function doRead(input) {
	var reader = new FileReader();
	reader.onload = function(e) {
		p.textContent = '';
		var header = doIt(e.target.result);
		var source = atob(e.target.result.substr(23));
		var offset = source.charCodeAt(4) * 256 + source.charCodeAt(5) + 4;
		//p.textContent = btoa(header + source.substr(offset, 2000));
	};
	reader.readAsDataURL(input.files[0]);
}

var fieldLengths = [null, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8];
var rBaseAddress = 12;

function doIt(source) {
	Exif.read(source);
	return Exif.write().join('');
}

var Exif = {
	read: function(source) {
		this.rIndex = 0;
		this.rBigEndian = true;
		this.orientation = 0;
		this.wBytes = [];
		this.wIndex = 0;
		this.wDataAddress = 0;

		/*if (source instanceof Ci.nsIFile) {
			istream = Cc ["@mozilla.org/network/file-input-stream;1"].createInstance (Ci.nsIFileInputStream);
			istream.init (source, -1, -1, false);
			bstream = Cc ["@mozilla.org/binaryinputstream;1"].createInstance (Ci.nsIBinaryInputStream);
			bstream.setInputStream (istream);
			this.rBytes = bstream.readBytes(bstream.available());
			bstream.close ();
			istream.close ();
		} else*/ if (source.constructor.name == "String" && /^data:image\/jpeg;base64,/.test (source)) {
			this.rBytes = atob(source.substring(23));
		} else {
			throw "not a file";
		}

		if (this.read2Bytes() != 0xffd8) {
			throw "not a jpeg";
		}
		var current = this.read2Bytes();
		if (current == 0xffe0) {
			var sectionLength = this.read2Bytes();
			this.rIndex = sectionLength + 2;
			current = this.read2Bytes();
		}
		if (current != 0xffe1) {
			throw "no valid exif data";
		}
		this.rIndex += 8;
		this.rBigEndian = this.read2Bytes() == 0x4d4d;
		this.rIndex += 6;

		var exif1Count = this.read2Bytes();
		//alert(exif1Count);
		//if (exif1Count != 9) throw "bad"
		var exif1 = this.readSection(exif1Count)

		this.rIndex = this.intFromBytes(exif1["8769"].data) + rBaseAddress;
		var exif2Count = this.read2Bytes();
		//alert(exif2Count);
		//if (exif2Count != 26) throw "bad";
		var exif2 = this.readSection(exif2Count);

		var gps = null;
		if ("8825" in exif1) {
			this.rIndex = this.intFromBytes(exif1["8825"].data) + rBaseAddress;
			var gpsCount = this.read2Bytes();
			//alert(gpsCount);
			//if (gpsCount != 7) throw "bad";
			gps = this.readSection(gpsCount);
		/*} else if ("a404" in exif2) {
			this.rIndex = this.intFromBytes(exif2["a404"].data) + rBaseAddress;
			var gpsCount = this.read2Bytes();
			//alert(gpsCount);
			//if (gpsCount != 7) throw "bad";
			gps = this.readSection(gpsCount);*/
		}

		if ("112" in exif1) {
			switch (this.shortFromBytes(exif1["112"].data)) {
			case 8:
				this.orientation = 90;
				break;
			case 3:
				this.orientation = 180;
				break;
			case 6:
				this.orientation = 270;
				break;
			}
		}

		["112", "11a", "11b", "128", "213"].forEach(function(key) {
			delete exif1[key];
		});
		["927c", "9286", "a005", "a210"].forEach(function(key) {
			delete exif2[key];
		});

		this.exif1 = exif1;
		this.exif2 = exif2;
		this.gps = gps;
	},
	write: function() {
		this.write2Bytes(0xD8FF); // SOI marker, big endian
		this.write2Bytes(0xE1FF); // APP1 marker, big endian
		this.write2Bytes(0x0000); // APP1 size, corrected later
		this.write4Bytes(0x66697845); // Exif, big endian
		this.write2Bytes(0x0000);
		this.write2Bytes(0x4949);
		this.write2Bytes(0x002A);
		this.write4Bytes(0x00000008);

		var exif1Address = this.wIndex - rBaseAddress;
		var exif2Address = exif1Address + this.getSectionSize(this.exif1);
		this.exif1["8769"].data = this.bytesFromInt(exif2Address);
		//this.exif1["8769"].values[0] = exif2Address;

		if (this.gps) {
			var gpsAddress = exif2Address + this.getSectionSize(this.exif2);
			if ("8825" in this.exif1) {
				this.exif1["8825"].data = this.bytesFromInt(gpsAddress);
				//this.exif1["8825"].values[0] = gpsAddress;
			}
			/*if ("a404" in this.exif2) {
				this.exif2["a404"].data = this.bytesFromInt(gpsAddress);
				//this.exif2["a404"].values[0] = gpsAddress;
			}*/
		}

		this.writeSection(this.exif1);
		this.wIndex = this.wDataAddress;
		this.writeSection(this.exif2);
		if (this.gps) {
			this.wIndex = this.wDataAddress;
			this.writeSection(this.gps);
		}

		var length = this.wDataAddress - 4;
		this.wBytes[4] = (length & 0xff00) >> 8;
		this.wBytes[5] = length & 0x00ff;

		//var hex2 = '';
		var str = [];
		for (var i = 0; i < this.wDataAddress; i++) {
			var c = this.wBytes[i] || 0;
			str.push(String.fromCharCode(c));
			/*if (!(i in this.wBytes)) {
				//c = 0xff;
			}
			//if (i == exif2Address) hex2 += '***';
			hex2 += (c < 16 ? '0' + c.toString(16) : c.toString(16)) + ' ';
			if (i % 16 == 15)
				//hex2 += '\n' + ((i + 1) / 16) + ' ';
				hex2 += '\n';*/
		}
		/*if (i % 16 != 0)
			hex2 += '\n';
		p.textContent += hex2 + '-----------------\n';*/
		//throw "hammertime";
		return str;
	},
	shortFromBytes: function(bytes) {
		if (this.rBigEndian) {
			return bytes.charCodeAt(0) * 0x0100 +
				bytes.charCodeAt(1);
		} else {
			return bytes.charCodeAt(0) +
				bytes.charCodeAt(1) * 0x0100;
		}
	},
	intFromBytes: function(bytes) {
		if (this.rBigEndian) {
			return bytes.charCodeAt(0) * 0x01000000 +
				bytes.charCodeAt(1) * 0x010000 +
				bytes.charCodeAt(2) * 0x0100 +
				bytes.charCodeAt(3);
		} else {
			return bytes.charCodeAt(0) +
				bytes.charCodeAt(1) * 0x0100 +
				bytes.charCodeAt(2) * 0x010000 +
				bytes.charCodeAt(3) * 0x01000000;
		}
	},
	bytesFromInt: function(aInt) {
		return String.fromCharCode(aInt & 0x000000ff, (aInt & 0x0000ff00) >> 8, (aInt & 0x00ff0000) >> 16, (aInt & 0xff000000) >> 24);
	},
	read2Bytes: function() {
		if (this.rBigEndian) {
			return this.rBytes.charCodeAt(this.rIndex++) * 0x0100 +
				this.rBytes.charCodeAt(this.rIndex++);
		} else {
			return this.rBytes.charCodeAt(this.rIndex++) +
				this.rBytes.charCodeAt(this.rIndex++) * 0x0100;
		}
	},
	read4Bytes: function() {
		if (this.rBigEndian) {
			return this.rBytes.charCodeAt(this.rIndex++) * 0x01000000 +
				this.rBytes.charCodeAt(this.rIndex++) * 0x010000 +
				this.rBytes.charCodeAt(this.rIndex++) * 0x0100 +
				this.rBytes.charCodeAt(this.rIndex++);
		} else {
			return this.rBytes.charCodeAt(this.rIndex++) +
				this.rBytes.charCodeAt(this.rIndex++) * 0x0100 +
				this.rBytes.charCodeAt(this.rIndex++) * 0x010000 +
				this.rBytes.charCodeAt(this.rIndex++) * 0x01000000;
		}
	},
	readField: function() {
		var code = this.read2Bytes().toString(16);
		var type = this.read2Bytes();
		var count = this.read4Bytes();
		var value = this.read4Bytes();
		var size = count * fieldLengths[type];

		var field = {
			code: code,
			type: type,
			count: count,
			size: size
		}

		if (code == "927c") {
			field.count = 4;
			field.size = 4;
			field.data = "****";
			return field;
		}

		if (size <= 4) {
			field.data = this.rBytes.substr(this.rIndex - 4, size);
		} else {
			field.data = this.rBytes.substr(value + rBaseAddress, size);
		}

		/*field.values = [];
		for (var j = 0; j < count; j++) {
			var value = field.data.substr(j * fieldLengths[type], fieldLengths[type]);
			switch(type) {
			case 1:
			case 6:
				field.values.push(value.charCodeAt(0));
				break;
			case 3:
			case 8:
				field.values.push(this.shortFromBytes(value));
				break;
			case 4:
			case 9:
				field.values.push(this.intFromBytes(value));
				break;
			case 5:
			case 10:
				field.values.push(this.intFromBytes(value) / this.intFromBytes(value.substring(4)));
				break;
			default:
				field.values.push(value);
			}
		}*/
		return field;
	},
	readSection: function(count) {
		var section = {};
		for (var i = 0; i < count; i++) {
			var field = this.readField();
			section[field.code] = field;
		}
		return section;
	},
	getSectionSize: function(data) {
		var size = 6;
		for (var e in data) {
			size += 12;
			if (data[e].size > 4) {
				size += data[e].size;
			}
		}
		return size;
	},
	write2Bytes: function(s) {
		this.wBytes[this.wIndex++] = (s & 0x00ff);
		this.wBytes[this.wIndex++] = ((s & 0xff00) >> 8);
	},
	write4Bytes: function(s) {
		this.wBytes[this.wIndex++] = (s & 0x000000ff);
		this.wBytes[this.wIndex++] = ((s & 0x0000ff00) >> 8);
		this.wBytes[this.wIndex++] = ((s & 0x00ff0000) >> 16);
		this.wBytes[this.wIndex++] = ((s & 0xff000000) >> 24);
	},
	writeField: function(field) {
		this.write2Bytes(parseInt(field.code, 16));
		this.write2Bytes(field.type);
		this.write4Bytes(field.count);
		if (field.size <= 4) {
			for (var i = 0; i < 4; i++) {
				this.wBytes[this.wIndex++] = (field.data.charCodeAt(i) || 0);
			}
		} else {
			var start = this.wDataAddress;
			this.write4Bytes(start - 12);
			this.wDataAddress += field.size;
			for (var i = 0; i < field.data.length; i++) {
				this.wBytes[start++] = (field.data.charCodeAt(i));
			}
		}
	},
	writeSection: function(data) {
		p.textContent += '-----------------\n';
		var count = 0;
		this.wDataAddress = this.wIndex + 6;
		for (var e in data) {
			p.textContent += JSON.stringify(data[e]) + '\n';
			count++;
			this.wDataAddress += 12;
		}

		this.write2Bytes(count);
		for (var e in data) {
			this.writeField(data[e]);
		}
	}
}

</script>
